import { NextResponse } from 'next/server';
import { db } from '@/lib/data/system';
import { users, creatorApplications, creatorSettings, aiTwinSettings, creatorInvites } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { supabaseAdmin } from '@/lib/supabase/admin';
import { sendCreatorApprovalEmail, addCreatorToAudience } from '@/lib/email';
import { withAdminParams } from '@/lib/auth/withAdmin';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

/**
 * POST /api/admin/creator-applications/[id]/approve
 * Approve a creator application
 */
export const POST = withAdminParams<{ id: string }>(async ({ user, params, request }) => {
  try {
    const { id } = await params;

    // Get the application with user data
    const application = await db.query.creatorApplications.findFirst({
      where: eq(creatorApplications.id, id),
      with: {
        user: {
          columns: {
            id: true,
            username: true,
            email: true,
          },
        },
      },
    });

    if (!application) {
      return NextResponse.json({ error: 'Application not found' }, { status: 404 });
    }

    if (application.status !== 'pending') {
      return NextResponse.json(
        { error: `Application has already been ${application.status}` },
        { status: 400 }
      );
    }

    const body = await request.json().catch(() => ({}));
    const { adminNotes } = body;

    // Determine if we should update the username from Instagram handle
    let newUsername: string | null = null;
    const currentUsername = application.user?.username || '';
    const isAutoGenerated = currentUsername.startsWith('user_');

    if (isAutoGenerated && application.instagramHandle) {
      // Clean up Instagram handle to make a valid username
      const cleanedHandle = application.instagramHandle
        .toLowerCase()
        .replace(/^@/, '')
        .replace(/[^a-z0-9_]/g, '_')
        .replace(/_+/g, '_')
        .replace(/^_|_$/g, '')
        .slice(0, 20);

      // Validate format (must start with letter, 3-20 chars)
      if (/^[a-z][a-z0-9_]{2,19}$/.test(cleanedHandle)) {
        // Check if username is available
        const existingUser = await db.query.users.findFirst({
          where: eq(users.username, cleanedHandle),
          columns: { id: true },
        });

        if (!existingUser) {
          newUsername = cleanedHandle;
          console.log(`[Creator Application] Will set username to @${newUsername} from Instagram handle`);
        } else {
          console.log(`[Creator Application] Instagram handle @${cleanedHandle} already taken, keeping auto-generated username`);
        }
      }
    }

    // Use a transaction for atomicity
    await db.transaction(async (tx) => {
      // 1. Update application status
      await tx.update(creatorApplications)
        .set({
          status: 'approved',
          reviewedBy: user.id,
          reviewedAt: new Date(),
          adminNotes: adminNotes || null,
          updatedAt: new Date(),
        })
        .where(eq(creatorApplications.id, id));

      // 2. Update user role to creator
      const userUpdate: Record<string, unknown> = {
        role: 'creator',
        isCreatorVerified: false,
        displayName: application.displayName || undefined,
        updatedAt: new Date(),
      };

      if (newUsername) {
        userUpdate.username = newUsername;
      }

      await tx.update(users)
        .set(userUpdate)
        .where(eq(users.id, application.userId));

      // 3. Create default creator settings
      await tx.insert(creatorSettings).values({
        userId: application.userId,
        messageRate: 3,
        callRatePerMinute: 25,
        minimumCallDuration: 5,
        isAvailableForCalls: true,
        voiceCallRatePerMinute: 15,
        minimumVoiceCallDuration: 5,
        isAvailableForVoiceCalls: true,
      }).onConflictDoNothing();

      // 4. Create default AI Twin settings
      await tx.insert(aiTwinSettings).values({
        creatorId: application.userId,
        enabled: false,
        textChatEnabled: false,
        voice: 'ara',
        pricePerMinute: 20,
        minimumMinutes: 5,
        maxSessionMinutes: 60,
        textPricePerMessage: 5,
      }).onConflictDoNothing();
    });

    // 5. Update Supabase auth metadata (fire-and-forget)
    try {
      await supabaseAdmin.auth.admin.updateUserById(application.userId, {
        app_metadata: { role: 'creator' },
      });
    } catch (authError) {
      console.error('[Creator Application] Failed to update auth metadata:', authError);
    }

    console.log(`[Creator Application] Approved: ${application.userId} by ${user.id}`);

    // 6. Auto-link pending invite if Instagram handle matches
    if (application.instagramHandle) {
      const normalizedHandle = application.instagramHandle.toLowerCase().replace('@', '');
      try {
        const updatedInvites = await db.update(creatorInvites)
          .set({
            status: 'claimed',
            claimedBy: application.userId,
            claimedAt: new Date(),
            updatedAt: new Date(),
          })
          .where(
            and(
              eq(creatorInvites.instagramHandle, normalizedHandle),
              eq(creatorInvites.status, 'pending')
            )
          )
          .returning({ id: creatorInvites.id });

        if (updatedInvites.length > 0) {
          console.log(`[Creator Application] Auto-linked pending invite for @${normalizedHandle} to user ${application.userId}`);
        }
      } catch (inviteError) {
        console.error('[Creator Application] Failed to auto-link invite:', inviteError);
      }
    }

    // 7. Send approval email notification
    if (application.user?.email) {
      const creatorData = {
        email: application.user.email,
        name: application.displayName || newUsername || application.user.username || 'Creator',
        username: newUsername || application.user.username || '',
      };

      Promise.all([
        sendCreatorApprovalEmail(creatorData),
        addCreatorToAudience(creatorData),
      ]).then(([emailResult, audienceResult]) => {
        if (emailResult.success) {
          console.log(`[Creator Application] Approval email sent to ${creatorData.email}`);
        } else {
          console.error(`[Creator Application] Failed to send approval email:`, emailResult.error);
        }
        if (audienceResult.success) {
          console.log(`[Creator Application] Added ${creatorData.email} to creators audience`);
        }
      }).catch((err) => {
        console.error('[Creator Application] Email/audience error:', err);
      });
    }

    return NextResponse.json({
      success: true,
      message: 'Application approved successfully',
    });
  } catch (error: unknown) {
    console.error('Error approving creator application:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { error: `Failed to approve application: ${errorMessage}` },
      { status: 500 }
    );
  }
});
